// Copyright (c) 2024 Coinbase Chain
// Distributed under the MIT software license

#include "validation/chainstate_manager.hpp"
#include "validation/validation.hpp"
#include "chain/block_manager.hpp"
#include "chain/chainparams.hpp"
#include "crypto/randomx_pow.hpp"
#include "notifications.hpp"
#include "util/logging.hpp"
#include <ctime>
#include <iostream>

namespace coinbasechain {
namespace validation {

// Maximum reorg depth before we warn/error
static constexpr int MAX_REORG_DEPTH = 6;  // Conservative like Bitcoin
static constexpr int SUSPICIOUS_REORG_DEPTH = 100;  // Halt if reorg exceeds this

ChainstateManager::ChainstateManager(const chain::ChainParams& params,
                                     int suspicious_reorg_depth)
    : block_manager_()
    , params_(params)
    , suspicious_reorg_depth_(suspicious_reorg_depth)
{
}

chain::CBlockIndex* ChainstateManager::AcceptBlockHeader(const CBlockHeader& header,
                                                         ValidationState& state,
                                                         bool min_pow_checked)
{
    std::lock_guard<std::mutex> lock(validation_mutex_);

    uint256 hash = header.GetHash();

    // Genesis blocks must be added via Initialize(), not AcceptBlockHeader
    if (hash == params_.GetConsensus().hashGenesisBlock) {
        state.Invalid("genesis-via-accept", "genesis block must be added via Initialize()");
        return nullptr;
    }

    // Step 1: Check for duplicate
    chain::CBlockIndex* pindex = block_manager_.LookupBlockIndex(hash);
    if (pindex) {
        // Block header is already known
        if (pindex->nStatus & chain::BLOCK_FAILED_MASK) {
            LOG_DEBUG("Block header {} is marked invalid", hash.ToString().substr(0, 16));
            state.Invalid("duplicate", "block is marked invalid");
            return nullptr;
        }
        // Already have it and it's valid
        return pindex;
    }

    // Step 2: Cheap POW commitment check (anti-DoS)
    if (!crypto::CheckProofOfWorkRandomX(
                header,
                header.nBits,
                params_.GetConsensus().nRandomXEpochDuration,
                crypto::POWVerifyMode::COMMITMENT_ONLY)) {
        state.Invalid("high-hash", "proof of work commitment failed");
        LOG_DEBUG("Block header {} failed POW commitment check", hash.ToString().substr(0, 16));
        return nullptr;
    }

    // Step 3: Check if parent exists
    chain::CBlockIndex* pindexPrev = block_manager_.LookupBlockIndex(header.hashPrevBlock);
    if (!pindexPrev) {
        LOG_DEBUG("Block header {} has prev block not found: {}",
                 hash.ToString().substr(0, 16),
                 header.hashPrevBlock.ToString().substr(0, 16));
        state.Invalid("prev-blk-not-found", "previous block not found");
        return nullptr;
    }

    // Step 4: Check if parent is marked invalid
    if (pindexPrev->nStatus & chain::BLOCK_FAILED_MASK) {
        LOG_DEBUG("Block header {} has prev block invalid: {}",
                 hash.ToString().substr(0, 16),
                 header.hashPrevBlock.ToString().substr(0, 16));
        state.Invalid("bad-prevblk", "previous block is invalid");
        return nullptr;
    }

    // Step 5: Check if descends from any known invalid block
    if (!pindexPrev->IsValid(chain::BLOCK_VALID_TREE)) {
        // Check against failed blocks list
        for (chain::CBlockIndex* failedit : m_failed_blocks) {
            if (pindexPrev->GetAncestor(failedit->nHeight) == failedit) {
                // This block descends from a known invalid block
                // Mark all blocks between pindexPrev and failedit as BLOCK_FAILED_CHILD
                chain::CBlockIndex* invalid_walk = pindexPrev;
                while (invalid_walk != failedit) {
                    invalid_walk->nStatus |= chain::BLOCK_FAILED_CHILD;
                    invalid_walk = invalid_walk->pprev;
                }
                LOG_DEBUG("Block header {} has prev block that descends from invalid block",
                         hash.ToString().substr(0, 16));
                state.Invalid("bad-prevblk", "previous block descends from invalid block");
                return nullptr;
            }
        }
    }

    // Step 6: Check min_pow_checked (anti-DoS)
    if (!min_pow_checked) {
        LOG_DEBUG("Block header {} rejected: missing anti-DoS POW validation",
                 hash.ToString().substr(0, 16));
        state.Invalid("too-little-chainwork", "missing anti-DoS proof-of-work validation");
        return nullptr;
    }

    // Step 7: Add to block index BEFORE expensive validation
    // This ensures we cache the result of expensive operations (PoW verification)
    // If block fails validation below, we mark it invalid and never re-validate
    pindex = block_manager_.AddToBlockIndex(header);
    if (!pindex) {
        state.Error("failed to add block to index");
        return nullptr;
    }

    // Step 8: Contextual check
    int64_t adjusted_time = GetAdjustedTime();
    if (!ContextualCheckBlockHeader(header, pindexPrev, params_, adjusted_time, state)) {
        LOG_ERROR("Contextual check failed for block {}: {} - {}",
                 hash.ToString().substr(0, 16),
                 state.GetRejectReason(),
                 state.GetDebugMessage());
        // Mark as invalid and track it
        pindex->nStatus |= chain::BLOCK_FAILED_VALID;
        m_failed_blocks.insert(pindex);
        return nullptr;
    }

    // Step 9: Full POW verification (EXPENSIVE - this is why we cache the result)
    if (!CheckBlockHeader(header, params_, state)) {
        LOG_ERROR("Block header check failed for block {}: {} - {}",
                 hash.ToString().substr(0, 16),
                 state.GetRejectReason(),
                 state.GetDebugMessage());
        // Mark as invalid and track it
        pindex->nStatus |= chain::BLOCK_FAILED_VALID;
        m_failed_blocks.insert(pindex);
        return nullptr;
    }

    // Step 10: Mark as validated to TREE level
    [[maybe_unused]] bool raised = pindex->RaiseValidity(chain::BLOCK_VALID_TREE);

    // Step 11: Update best header
    chain_selector_.UpdateBestHeader(pindex);

    LOG_INFO("Accepted new block header: hash={}, height={}, work={}",
             hash.ToString().substr(0, 16),
             pindex->nHeight,
             pindex->nChainWork.ToString().substr(0, 16));

    return pindex;
}

bool ChainstateManager::ProcessNewBlockHeader(const CBlockHeader& header,
                                              ValidationState& state)
{
    // Accept the block header (validates and adds to index)
    chain::CBlockIndex* pindex = AcceptBlockHeader(header, state, true);

    if (!pindex) {
        // Validation failed
        return false;
    }

    // Add to candidate set (if it's a viable tip)
    chain_selector_.TryAddBlockIndexCandidate(pindex, block_manager_);

    // Block accepted - now try to activate best chain
    return ActivateBestChain(nullptr); // Will search candidates
}

bool ChainstateManager::ActivateBestChain(chain::CBlockIndex* pindexMostWork)
{
    std::lock_guard<std::mutex> lock(validation_mutex_);

    // Find block with most work if not provided
    if (!pindexMostWork) {
        pindexMostWork = chain_selector_.FindMostWorkChain();
    }

    if (!pindexMostWork) {
        LOG_ERROR("ChainstateManager: No valid chain found");
        return false;
    }

    // Get current tip
    chain::CBlockIndex* pindexOldTip = block_manager_.GetTip();

    LOG_DEBUG("ActivateBestChain: pindexOldTip={} (height={}), pindexMostWork={} (height={})",
             pindexOldTip ? pindexOldTip->GetBlockHash().ToString().substr(0, 16) : "null",
             pindexOldTip ? pindexOldTip->nHeight : -1,
             pindexMostWork->GetBlockHash().ToString().substr(0, 16),
             pindexMostWork->nHeight);

    // Check if this is actually a new tip
    if (pindexOldTip == pindexMostWork) {
        // Already at best tip
        return true;
    }

    // Check if new chain has more work
    if (pindexOldTip && pindexMostWork->nChainWork <= pindexOldTip->nChainWork) {
        // Not enough work to switch
        LOG_DEBUG("Block accepted but not activated (insufficient work). Height: {}, Hash: {}",
                 pindexMostWork->nHeight,
                 pindexMostWork->GetBlockHash().ToString().substr(0, 16));
        return true;
    }

    // Find the fork point between old and new chains
    const chain::CBlockIndex* pindexFork = chain::LastCommonAncestor(pindexOldTip, pindexMostWork);

    LOG_DEBUG("ActivateBestChain: pindexFork={} (height={})",
             pindexFork ? pindexFork->GetBlockHash().ToString().substr(0, 16) : "null",
             pindexFork ? pindexFork->nHeight : -1);

    // Handle the case where no fork point exists (chains have no common ancestor)
    if (!pindexFork) {
        LOG_ERROR("ActivateBestChain: No common ancestor found between old tip and new chain");
        LOG_ERROR("  Old tip: height={}, hash={}",
                 pindexOldTip ? pindexOldTip->nHeight : -1,
                 pindexOldTip ? pindexOldTip->GetBlockHash().ToString().substr(0, 16) : "null");
        LOG_ERROR("  New tip: height={}, hash={}",
                 pindexMostWork->nHeight,
                 pindexMostWork->GetBlockHash().ToString().substr(0, 16));
        return false;
    }

    // Calculate reorg depth (how many blocks will be disconnected)
    // Use height difference
    int reorg_depth = pindexOldTip->nHeight - pindexFork->nHeight;

    LOG_DEBUG("ActivateBestChain: reorg_depth={}, suspicious_reorg_depth_={}",
             reorg_depth, suspicious_reorg_depth_);

    // Deep reorg protection 
    // If suspiciousreorgdepth=N, reject reorgs >= N (allow up to N-1)
    if (suspicious_reorg_depth_ > 0 && reorg_depth >= suspicious_reorg_depth_) {
        LOG_ERROR("CRITICAL: Detected suspicious reorg of {} blocks, local policy allows {} blocks. "
                 "This may indicate a severe network issue or attack. Refusing to reorganize.",
                 reorg_depth, suspicious_reorg_depth_ - 1);
        LOG_ERROR("* current tip @ height {} ({})", pindexOldTip->nHeight,
                 pindexOldTip->GetBlockHash().ToString());
        LOG_ERROR("*   reorg tip @ height {} ({})", pindexMostWork->nHeight,
                 pindexMostWork->GetBlockHash().ToString());
        LOG_ERROR("*  fork point @ height {} ({})", pindexFork->nHeight,
                 pindexFork->GetBlockHash().ToString());
        return false;
    }

    if (reorg_depth > MAX_REORG_DEPTH) {
        LOG_WARN("WARNING: Large reorg detected! Disconnecting {} blocks. "
                "Fork point at height {}. This is unusual but proceeding.",
                reorg_depth, pindexFork ? pindexFork->nHeight : -1);
    }

    // Disconnect blocks from old tip back to fork point
    std::vector<const chain::CBlockIndex*> disconnected_blocks;
    chain::CBlockIndex* pindexWalk = pindexOldTip;
    while (pindexWalk && pindexWalk != pindexFork) {
        disconnected_blocks.push_back(pindexWalk);
        if (!DisconnectTip()) {
            LOG_ERROR("Failed to disconnect block during reorg");
            return false;
        }
        pindexWalk = block_manager_.GetTip();
    }

    // Connect blocks from fork point to new tip
    std::vector<chain::CBlockIndex*> connect_blocks;
    pindexWalk = pindexMostWork;
    while (pindexWalk && pindexWalk != pindexFork) {
        connect_blocks.push_back(pindexWalk);
        pindexWalk = pindexWalk->pprev;
    }

    // Connect in reverse order (from fork to tip)
    for (auto it = connect_blocks.rbegin(); it != connect_blocks.rend(); ++it) {
        if (!ConnectTip(*it)) {
            LOG_ERROR("Failed to connect block during reorg at height {}",
                     (*it)->nHeight);

            // ERROR RECOVERY: Roll back to old tip
            LOG_WARN("Attempting to roll back to old tip...");

            // First, disconnect any blocks we successfully connected
            while (block_manager_.GetTip() != pindexFork) {
                if (!DisconnectTip()) {
                    LOG_ERROR("CRITICAL: Rollback failed! Chain state may be inconsistent!");
                    return false;
                }
            }

            // Now reconnect the old chain
            for (auto rit = disconnected_blocks.rbegin(); rit != disconnected_blocks.rend(); ++rit) {
                if (!ConnectTip(const_cast<chain::CBlockIndex*>(*rit))) {
                    LOG_ERROR("CRITICAL: Failed to restore old chain! Chain state may be inconsistent!");
                    return false;
                }
            }

            LOG_INFO("Rollback successful - restored old tip at height {}",
                    block_manager_.GetTip()->nHeight);
            return false;
        }
    }

    // Log reorg information
    if (!disconnected_blocks.empty()) {
        LOG_WARN("REORGANIZE: Disconnect {} blocks; Connect {} blocks",
                 disconnected_blocks.size(), connect_blocks.size());
        LOG_INFO("REORGANIZE: Old tip: height={}, hash={}",
                 pindexOldTip->nHeight,
                 pindexOldTip->GetBlockHash().ToString().substr(0, 16));
        LOG_INFO("REORGANIZE: New tip: height={}, hash={}",
                 pindexMostWork->nHeight,
                 pindexMostWork->GetBlockHash().ToString().substr(0, 16));
        LOG_INFO("REORGANIZE: Fork point: height={}, hash={}",
                 pindexFork ? pindexFork->nHeight : -1,
                 pindexFork ? pindexFork->GetBlockHash().ToString().substr(0, 16) : "null");
    } else {
        LOG_INFO("New best chain activated! Height: {}, Hash: {}, Work: {}",
                 pindexMostWork->nHeight,
                 pindexMostWork->GetBlockHash().ToString().substr(0, 16),
                 pindexMostWork->nChainWork.ToString().substr(0, 16));
    }

    // Emit final tip notification
    Notifications().NotifyChainTip(pindexMostWork, pindexMostWork->nHeight);

    // Prune candidates that now have less work than active tip
    chain_selector_.PruneBlockIndexCandidates(block_manager_);

    return true;
}

const chain::CBlockIndex* ChainstateManager::GetTip() const
{
    std::lock_guard<std::mutex> lock(validation_mutex_);
    return block_manager_.GetTip();
}

chain::CBlockIndex* ChainstateManager::LookupBlockIndex(const uint256& hash)
{
    std::lock_guard<std::mutex> lock(validation_mutex_);
    return block_manager_.LookupBlockIndex(hash);
}

const chain::CBlockIndex* ChainstateManager::LookupBlockIndex(const uint256& hash) const
{
    std::lock_guard<std::mutex> lock(validation_mutex_);
    return block_manager_.LookupBlockIndex(hash);
}

CBlockLocator ChainstateManager::GetLocator(const chain::CBlockIndex* pindex) const
{
    std::lock_guard<std::mutex> lock(validation_mutex_);
    if (pindex) {
        return chain::GetLocator(pindex);
    }
    return block_manager_.ActiveChain().GetLocator();
}

bool ChainstateManager::IsOnActiveChain(const chain::CBlockIndex* pindex) const
{
    std::lock_guard<std::mutex> lock(validation_mutex_);
    return pindex && block_manager_.ActiveChain().Contains(pindex);
}

const chain::CBlockIndex* ChainstateManager::GetBlockAtHeight(int height) const
{
    std::lock_guard<std::mutex> lock(validation_mutex_);
    if (height < 0 || height > block_manager_.ActiveChain().Height()) {
        return nullptr;
    }
    return block_manager_.ActiveChain()[height];
}


bool ChainstateManager::ConnectTip(chain::CBlockIndex* pindexNew)
{
    if (!pindexNew) {
        LOG_ERROR("ConnectTip: null block index");
        return false;
    }

    // For headers-only chain, "connecting" just means:
    // 1. Setting this as the active tip
    // 2. Emitting notifications

    block_manager_.SetActiveTip(*pindexNew);

    LOG_DEBUG("ConnectTip: height={}, hash={}",
             pindexNew->nHeight,
             pindexNew->GetBlockHash().ToString().substr(0, 16));

    // Emit block connected notification
    CBlockHeader header = pindexNew->GetBlockHeader();
    Notifications().NotifyBlockConnected(header, pindexNew);

    return true;
}

bool ChainstateManager::DisconnectTip()
{
    chain::CBlockIndex* pindexDelete = block_manager_.GetTip();
    if (!pindexDelete) {
        LOG_ERROR("DisconnectTip: no tip to disconnect");
        return false;
    }

    if (!pindexDelete->pprev) {
        LOG_ERROR("DisconnectTip: cannot disconnect genesis block");
        return false;
    }

    LOG_DEBUG("DisconnectTip: height={}, hash={}",
             pindexDelete->nHeight,
             pindexDelete->GetBlockHash().ToString().substr(0, 16));

    // Emit notification BEFORE disconnecting
    CBlockHeader header = pindexDelete->GetBlockHeader();
    Notifications().NotifyBlockDisconnected(header, pindexDelete);

    // For headers-only chain, "disconnecting" just means:
    // Moving the active tip pointer back to parent
    block_manager_.SetActiveTip(*pindexDelete->pprev);

    return true;
}

void ChainstateManager::TryAddBlockIndexCandidate(chain::CBlockIndex* pindex)
{
    std::lock_guard<std::mutex> lock(validation_mutex_);

    if (!pindex) {
        return;
    }

    // A block is a candidate if it could be a valid chain tip
    // Criteria:
    // 1. It has no known children (it's a leaf in the block tree)
    // 2. It has been validated to at least TREE level

    // Check validation status
    if (!pindex->IsValid(chain::BLOCK_VALID_TREE)) {
        LOG_DEBUG("Block {} not added to candidates: not validated to TREE level",
                 pindex->GetBlockHash().ToString().substr(0, 16));
        return;
    }

    // CRITICAL SAFETY CHECK: Verify this block has no children
    // A block can only be a candidate if it's a leaf node (no descendants)
    // This prevents interior nodes from being activated, which would lose
    // parts of the active chain
    //
    // Note: This is an O(n) check over all blocks in the index, but it's necessary
    // for correctness. In practice, TryAddBlockIndexCandidate is only called:
    // 1. When a new block is accepted (guaranteed to be a leaf)
    // 2. During Initialize (genesis has no children)
    // 3. During Load (tip is guaranteed to be a leaf)
    // So this check should rarely reject blocks in correct usage.
    bool has_children = false;
    for (const auto& [hash, block_index] : block_manager_.GetBlockIndex()) {
        if (block_index.pprev == pindex) {
            has_children = true;
            LOG_WARN("Block {} not added to candidates: has child {} (not a leaf)",
                    pindex->GetBlockHash().ToString().substr(0, 16),
                    hash.ToString().substr(0, 16));
            break;
        }
    }
    if (has_children) {
        return;
    }

    // CRITICAL: If this block extends a previous candidate (its parent was a candidate),
    // we must remove the parent from candidates since it's no longer a tip.
    // This prevents the candidate set from filling up with non-tip blocks.
    if (pindex->pprev) {
        auto it = setBlockIndexCandidates.find(pindex->pprev);
        if (it != setBlockIndexCandidates.end()) {
            LOG_DEBUG("Removed parent from candidates (extended): height={}, hash={}",
                     pindex->pprev->nHeight,
                     pindex->pprev->GetBlockHash().ToString().substr(0, 16));
            setBlockIndexCandidates.erase(it);
        }
    }

    // Add the new block as a candidate
    setBlockIndexCandidates.insert(pindex);

    LOG_DEBUG("Added candidate: height={}, hash={}, work={}, candidates_count={}",
             pindex->nHeight,
             pindex->GetBlockHash().ToString().substr(0, 16),
             pindex->nChainWork.ToString().substr(0, 16),
             setBlockIndexCandidates.size());
}

void ChainstateManager::PruneBlockIndexCandidates()
{
    // Remove all candidates that should no longer be considered as tips:
    // 1. Blocks with less chainwork than current tip (lost competition)
    // 2. The current tip itself (no longer competing)
    // 3. Any ancestor of the current tip (interior of active chain)
    // 4. Any block with children (not a leaf - should never happen but be defensive)

    chain::CBlockIndex* pindexTip = block_manager_.GetTip();
    if (!pindexTip) {
        return;
    }

    // Build set of all blocks that have children (for leaf check)
    const auto& block_index = block_manager_.GetBlockIndex();
    std::set<const chain::CBlockIndex*> blocks_with_children;
    for (const auto& [hash, block] : block_index) {
        if (block.pprev) {
            blocks_with_children.insert(block.pprev);
        }
    }

    auto it = setBlockIndexCandidates.begin();
    size_t removed = 0;

    while (it != setBlockIndexCandidates.end()) {
        chain::CBlockIndex* pindex = *it;
        bool should_remove = false;

        // Rule 1: Remove if less work than tip
        if (pindex->nChainWork < pindexTip->nChainWork) {
            LOG_DEBUG("Pruning candidate (less work): height={}, hash={}, work={} < tip_work={}",
                     pindex->nHeight,
                     pindex->GetBlockHash().ToString().substr(0, 16),
                     pindex->nChainWork.ToString().substr(0, 16),
                     pindexTip->nChainWork.ToString().substr(0, 16));
            should_remove = true;
        }
        // Rule 2: Remove if it IS the current tip
        else if (pindex == pindexTip) {
            LOG_DEBUG("Pruning candidate (is current tip): height={}, hash={}",
                     pindex->nHeight,
                     pindex->GetBlockHash().ToString().substr(0, 16));
            should_remove = true;
        }
        // Rule 3: Remove if it's an ancestor of the tip (interior of active chain)
        else if (block_manager_.ActiveChain().Contains(pindex)) {
            LOG_DEBUG("Pruning candidate (on active chain): height={}, hash={}",
                     pindex->nHeight,
                     pindex->GetBlockHash().ToString().substr(0, 16));
            should_remove = true;
        }
        // Rule 4: Remove if it has children (not a leaf - defensive check)
        else if (blocks_with_children.find(pindex) != blocks_with_children.end()) {
            LOG_WARN("Pruning candidate (has children, not a leaf!): height={}, hash={}",
                    pindex->nHeight,
                    pindex->GetBlockHash().ToString().substr(0, 16));
            should_remove = true;
        }

        if (should_remove) {
            it = setBlockIndexCandidates.erase(it);
            removed++;
        } else {
            ++it;
        }
    }

    if (removed > 0) {
        LOG_DEBUG("Pruned {} stale candidates (remaining: {})",
                 removed,
                 setBlockIndexCandidates.size());
    }
}

bool ChainstateManager::IsInitialBlockDownload() const
{
    // Fast path: check latch first (lock-free)
    if (m_cached_finished_ibd.load(std::memory_order_relaxed)) {
        return false;
    }

    // No tip yet - definitely in IBD
    const chain::CBlockIndex* tip = GetTip();
    if (!tip) {
        return true;
    }

    // Tip too old - still syncing (1 hour for 2-minute blocks)
    int64_t now = std::time(nullptr);
    if (tip->nTime < now - 3600) {
        return true;
    }

    // MinimumChainWork check (eclipse attack protection)
    // Prevents accepting fake low-work chains during IBD
    if (tip->nChainWork < UintToArith256(params_.GetConsensus().nMinimumChainWork)) {
        return true;
    }

    // All checks passed - we're synced!
    // Latch to false permanently
    LOG_INFO("Initial Block Download complete at height {}!", tip->nHeight);
    m_cached_finished_ibd.store(true, std::memory_order_relaxed);

    return false;
}

bool ChainstateManager::Initialize(const CBlockHeader& genesis_header)
{
    std::lock_guard<std::mutex> lock(validation_mutex_);

    if (!block_manager_.Initialize(genesis_header)) {
        return false;
    }

    // Initialize the candidate set with genesis block
    chain::CBlockIndex* genesis = block_manager_.GetTip();
    if (genesis) {
        setBlockIndexCandidates.insert(genesis);
        m_best_header = genesis;
        LOG_DEBUG("Initialized with genesis as candidate: height={}, hash={}",
                 genesis->nHeight,
                 genesis->GetBlockHash().ToString().substr(0, 16));
    }

    return true;
}

bool ChainstateManager::Load(const std::string& filepath)
{
    std::lock_guard<std::mutex> lock(validation_mutex_);

    if (!block_manager_.Load(filepath, params_.GetConsensus().hashGenesisBlock)) {
        return false;
    }

    // Rebuild the candidate set after loading from disk
    // We need to find all leaf nodes (tips) in the block tree
    setBlockIndexCandidates.clear();
    m_best_header = nullptr;

    // Walk through all blocks and find tips (blocks with no known children)
    // Algorithm:
    // 1. Build a set of all blocks that have children (by scanning pprev pointers)
    // 2. Any block NOT in that set is a leaf (potential candidate)
    // 3. Only add valid leaves (BLOCK_VALID_TREE) to candidates

    const auto& block_index = block_manager_.GetBlockIndex();

    // Step 1: Build set of blocks with children
    std::set<const chain::CBlockIndex*> blocks_with_children;
    for (const auto& [hash, block] : block_index) {
        if (block.pprev) {
            blocks_with_children.insert(block.pprev);
        }
    }

    // Step 2: Find all leaf nodes and add valid ones as candidates
    size_t leaf_count = 0;
    size_t candidate_count = 0;
    for (const auto& [hash, block] : block_index) {
        // Check if this block is a leaf (has no children)
        if (blocks_with_children.find(&block) == blocks_with_children.end()) {
            leaf_count++;

            // Only add as candidate if validated to TREE level
            if (block.IsValid(chain::BLOCK_VALID_TREE)) {
                // Need mutable pointer for candidate set
                chain::CBlockIndex* mutable_block =
                    const_cast<chain::CBlockIndex*>(&block);
                setBlockIndexCandidates.insert(mutable_block);
                candidate_count++;

                LOG_DEBUG("Added leaf as candidate: height={}, hash={}, work={}",
                         block.nHeight,
                         hash.ToString().substr(0, 16),
                         block.nChainWork.ToString().substr(0, 16));

                // Track best header (most chainwork)
                if (!m_best_header || block.nChainWork > m_best_header->nChainWork) {
                    m_best_header = mutable_block;
                }
            } else {
                LOG_DEBUG("Found invalid leaf (not added to candidates): height={}, hash={}, status={}",
                         block.nHeight,
                         hash.ToString().substr(0, 16),
                         block.nStatus);
            }
        }
    }

    chain::CBlockIndex* tip = block_manager_.GetTip();
    LOG_INFO("Loaded chain state: {} total blocks, {} leaf nodes, {} valid candidates",
             block_index.size(),
             leaf_count,
             candidate_count);

    if (tip) {
        LOG_INFO("Active chain tip: height={}, hash={}",
                 tip->nHeight,
                 tip->GetBlockHash().ToString().substr(0, 16));
    }

    if (m_best_header) {
        LOG_INFO("Best header: height={}, hash={}, work={}",
                 m_best_header->nHeight,
                 m_best_header->GetBlockHash().ToString().substr(0, 16),
                 m_best_header->nChainWork.ToString().substr(0, 16));
    }

    return true;
}

bool ChainstateManager::Save(const std::string& filepath) const
{
    std::lock_guard<std::mutex> lock(validation_mutex_);
    return block_manager_.Save(filepath);
}

size_t ChainstateManager::GetBlockCount() const
{
    std::lock_guard<std::mutex> lock(validation_mutex_);
    return block_manager_.GetBlockCount();
}

int ChainstateManager::GetChainHeight() const
{
    std::lock_guard<std::mutex> lock(validation_mutex_);
    return block_manager_.ActiveChain().Height();
}

} // namespace validation
} // namespace coinbasechain
