// Copyright (c) 2024 Coinbase Chain
// Distributed under the MIT software license
// Unit tests for network-adjusted time (timedata)

#include "util/timedata.hpp"
#include "util/time.hpp"
#include "catch_amalgamated.hpp"
#include <ctime>

using namespace coinbasechain::util;

TEST_CASE("TimeData - Initial state", "[timedata]") {
    TestOnlyResetTimeData();

    // Initially, time offset should be 0
    REQUIRE(GetTimeOffset() == 0);
}

TEST_CASE("TimeData - Single peer does not affect offset", "[timedata]") {
    TestOnlyResetTimeData();

    // Add one time sample (offset of +10 seconds)
    AddTimeData("192.168.1.1", 10);

    // With only 1 sample, offset should remain 0 (need at least 5)
    REQUIRE(GetTimeOffset() == 0);
}

TEST_CASE("TimeData - Four peers do not affect offset", "[timedata]") {
    TestOnlyResetTimeData();

    // Add 4 time samples
    // Note: CMedianFilter starts with initial value of 0, so we have [0, 10, 20, 15, 12] = 5 elements
    // But we need odd number >= 5 to update, and 5 is odd, so it WILL update!
    // Sorted: [0, 10, 12, 15, 20]
    // Median: 12
    AddTimeData("192.168.1.1", 10);
    AddTimeData("192.168.1.2", 20);
    AddTimeData("192.168.1.3", 15);
    AddTimeData("192.168.1.4", 12);

    // With 4 peer samples + initial 0 = 5 total (odd), median = 12
    REQUIRE(GetTimeOffset() == 12);
}

TEST_CASE("TimeData - Five peers with small offsets", "[timedata]") {
    TestOnlyResetTimeData();

    // Add 5 time samples: [10, 20, 15, 12, 18]
    // With initial 0: [0, 10, 20, 15, 12, 18] = 6 elements (even)
    // Sorted: [0, 10, 12, 15, 18, 20]
    // Even number, so offset stays at previous value (12 from test before)
    // But test is reset, so stays at 0
    AddTimeData("192.168.1.1", 10);
    AddTimeData("192.168.1.2", 20);
    AddTimeData("192.168.1.3", 15);
    AddTimeData("192.168.1.4", 12);
    AddTimeData("192.168.1.5", 18);

    // With 6 total samples (even number), offset doesn't update (stays 0)
    REQUIRE(GetTimeOffset() == 0);
}

TEST_CASE("TimeData - Six peers (even number of samples)", "[timedata]") {
    TestOnlyResetTimeData();

    // Add 6 time samples: [10, 20, 15, 12, 18, 25]
    // Sorted: [10, 12, 15, 18, 20, 25]
    // Median: (15 + 18) / 2 = 16 (integer division in CMedianFilter)
    AddTimeData("192.168.1.1", 10);
    AddTimeData("192.168.1.2", 20);
    AddTimeData("192.168.1.3", 15);
    AddTimeData("192.168.1.4", 12);
    AddTimeData("192.168.1.5", 18);
    AddTimeData("192.168.1.6", 25);

    // With 6 samples, offset should still be 15 (from when we had 5)
    // Note: Bitcoin Core has a "bug" where it only updates on odd sample counts
    REQUIRE(GetTimeOffset() == 15);
}

TEST_CASE("TimeData - Seven peers updates median", "[timedata]") {
    TestOnlyResetTimeData();

    // Add 7 time samples
    AddTimeData("192.168.1.1", 10);
    AddTimeData("192.168.1.2", 20);
    AddTimeData("192.168.1.3", 15);
    AddTimeData("192.168.1.4", 12);
    AddTimeData("192.168.1.5", 18);
    AddTimeData("192.168.1.6", 25);
    AddTimeData("192.168.1.7", 14);

    // Sorted: [10, 12, 14, 15, 18, 20, 25]
    // Median: 15 (middle element)
    REQUIRE(GetTimeOffset() == 15);
}

TEST_CASE("TimeData - Negative offsets", "[timedata]") {
    TestOnlyResetTimeData();

    // Peers are behind our clock
    // [-30, -20, -25, -22, -28]
    // Sorted: [-30, -28, -25, -22, -20]
    // Median: -25
    AddTimeData("192.168.1.1", -30);
    AddTimeData("192.168.1.2", -20);
    AddTimeData("192.168.1.3", -25);
    AddTimeData("192.168.1.4", -22);
    AddTimeData("192.168.1.5", -28);

    REQUIRE(GetTimeOffset() == -25);
}

TEST_CASE("TimeData - Mixed positive and negative offsets", "[timedata]") {
    TestOnlyResetTimeData();

    // Mix of ahead and behind
    // [-10, 5, -3, 8, 2]
    // Sorted: [-10, -3, 2, 5, 8]
    // Median: 2
    AddTimeData("192.168.1.1", -10);
    AddTimeData("192.168.1.2", 5);
    AddTimeData("192.168.1.3", -3);
    AddTimeData("192.168.1.4", 8);
    AddTimeData("192.168.1.5", 2);

    REQUIRE(GetTimeOffset() == 2);
}

TEST_CASE("TimeData - Adjustment cap at +70 minutes", "[timedata]") {
    TestOnlyResetTimeData();

    // All peers report we're 75 minutes behind (4500 seconds)
    // Median would be 4500, but cap is ±70 minutes (4200 seconds)
    AddTimeData("192.168.1.1", 4500);
    AddTimeData("192.168.1.2", 4500);
    AddTimeData("192.168.1.3", 4500);
    AddTimeData("192.168.1.4", 4500);
    AddTimeData("192.168.1.5", 4500);

    // Offset should be clamped to 0 (exceeds max adjustment)
    REQUIRE(GetTimeOffset() == 0);
}

TEST_CASE("TimeData - Adjustment cap at -70 minutes", "[timedata]") {
    TestOnlyResetTimeData();

    // All peers report we're 75 minutes ahead (-4500 seconds)
    AddTimeData("192.168.1.1", -4500);
    AddTimeData("192.168.1.2", -4500);
    AddTimeData("192.168.1.3", -4500);
    AddTimeData("192.168.1.4", -4500);
    AddTimeData("192.168.1.5", -4500);

    // Offset should be clamped to 0 (exceeds max adjustment)
    REQUIRE(GetTimeOffset() == 0);
}

TEST_CASE("TimeData - Exactly at +70 minute boundary", "[timedata]") {
    TestOnlyResetTimeData();

    // Exactly at the limit (70 * 60 = 4200 seconds)
    int64_t max_adjustment = DEFAULT_MAX_TIME_ADJUSTMENT; // 4200 seconds
    AddTimeData("192.168.1.1", max_adjustment);
    AddTimeData("192.168.1.2", max_adjustment);
    AddTimeData("192.168.1.3", max_adjustment);
    AddTimeData("192.168.1.4", max_adjustment);
    AddTimeData("192.168.1.5", max_adjustment);

    // Should be accepted (within limit)
    REQUIRE(GetTimeOffset() == max_adjustment);
}

TEST_CASE("TimeData - Exactly at -70 minute boundary", "[timedata]") {
    TestOnlyResetTimeData();

    int64_t max_adjustment = DEFAULT_MAX_TIME_ADJUSTMENT;
    AddTimeData("192.168.1.1", -max_adjustment);
    AddTimeData("192.168.1.2", -max_adjustment);
    AddTimeData("192.168.1.3", -max_adjustment);
    AddTimeData("192.168.1.4", -max_adjustment);
    AddTimeData("192.168.1.5", -max_adjustment);

    // Should be accepted (within limit)
    REQUIRE(GetTimeOffset() == -max_adjustment);
}

TEST_CASE("TimeData - One second over +70 minute limit", "[timedata]") {
    TestOnlyResetTimeData();

    int64_t over_limit = DEFAULT_MAX_TIME_ADJUSTMENT + 1; // 4201 seconds
    AddTimeData("192.168.1.1", over_limit);
    AddTimeData("192.168.1.2", over_limit);
    AddTimeData("192.168.1.3", over_limit);
    AddTimeData("192.168.1.4", over_limit);
    AddTimeData("192.168.1.5", over_limit);

    // Should be rejected (over limit)
    REQUIRE(GetTimeOffset() == 0);
}

TEST_CASE("TimeData - Duplicate peer addresses ignored", "[timedata]") {
    TestOnlyResetTimeData();

    // Same peer tries to submit multiple times
    AddTimeData("192.168.1.1", 10);
    AddTimeData("192.168.1.1", 50);  // Should be ignored (duplicate)
    AddTimeData("192.168.1.1", 100); // Should be ignored (duplicate)
    AddTimeData("192.168.1.2", 20);
    AddTimeData("192.168.1.3", 15);
    AddTimeData("192.168.1.4", 12);
    AddTimeData("192.168.1.5", 18);

    // Only first sample from 192.168.1.1 (offset=10) should count
    // Samples: [10, 20, 15, 12, 18]
    // Sorted: [10, 12, 15, 18, 20]
    // Median: 15
    REQUIRE(GetTimeOffset() == 15);
}

TEST_CASE("TimeData - Outlier resistance", "[timedata]") {
    TestOnlyResetTimeData();

    // Most peers agree (~10s offset), but one attacker claims huge offset
    // This tests that median is resistant to outliers
    // [10, 12, 11, 3000, 13]
    // Sorted: [10, 11, 12, 13, 3000]
    // Median: 12 (attacker's 3000 doesn't affect result)
    AddTimeData("192.168.1.1", 10);
    AddTimeData("192.168.1.2", 12);
    AddTimeData("192.168.1.3", 11);
    AddTimeData("192.168.1.4", 3000);  // Attacker
    AddTimeData("192.168.1.5", 13);

    REQUIRE(GetTimeOffset() == 12);
}

TEST_CASE("TimeData - Eclipse attack with majority", "[timedata]") {
    TestOnlyResetTimeData();

    // Attacker controls 3 out of 5 peers, trying to push time forward
    // [5000, 5000, 5000, 10, 12]
    // Sorted: [10, 12, 5000, 5000, 5000]
    // Median: 5000
    AddTimeData("attacker1", 5000);
    AddTimeData("attacker2", 5000);
    AddTimeData("attacker3", 5000);
    AddTimeData("honest1", 10);
    AddTimeData("honest2", 12);

    // Median would be 5000, but it exceeds ±70 min cap
    // So offset stays at 0 (protection against eclipse attack)
    REQUIRE(GetTimeOffset() == 0);
}

TEST_CASE("TimeData - Small variations around zero", "[timedata]") {
    TestOnlyResetTimeData();

    // Peers have very small offsets (good clock sync)
    // [-2, -1, 0, 1, 2]
    // Median: 0
    AddTimeData("192.168.1.1", -2);
    AddTimeData("192.168.1.2", -1);
    AddTimeData("192.168.1.3", 0);
    AddTimeData("192.168.1.4", 1);
    AddTimeData("192.168.1.5", 2);

    REQUIRE(GetTimeOffset() == 0);
}

TEST_CASE("TimeData - Many peers (9 samples)", "[timedata]") {
    TestOnlyResetTimeData();

    // Add 9 samples
    // [100, 110, 105, 95, 108, 102, 98, 106, 104]
    // Sorted: [95, 98, 100, 102, 104, 105, 106, 108, 110]
    // Median: 104 (middle element)
    AddTimeData("192.168.1.1", 100);
    AddTimeData("192.168.1.2", 110);
    AddTimeData("192.168.1.3", 105);
    AddTimeData("192.168.1.4", 95);
    AddTimeData("192.168.1.5", 108);
    AddTimeData("192.168.1.6", 102);
    AddTimeData("192.168.1.7", 98);
    AddTimeData("192.168.1.8", 106);
    AddTimeData("192.168.1.9", 104);

    REQUIRE(GetTimeOffset() == 104);
}

TEST_CASE("TimeData - Reset functionality", "[timedata]") {
    TestOnlyResetTimeData();

    // Add samples
    AddTimeData("192.168.1.1", 10);
    AddTimeData("192.168.1.2", 20);
    AddTimeData("192.168.1.3", 15);
    AddTimeData("192.168.1.4", 12);
    AddTimeData("192.168.1.5", 18);

    REQUIRE(GetTimeOffset() == 15);

    // Reset
    TestOnlyResetTimeData();

    // Offset should be back to 0
    REQUIRE(GetTimeOffset() == 0);

    // Should accept same peer addresses again after reset
    AddTimeData("192.168.1.1", 50);
    AddTimeData("192.168.1.2", 55);
    AddTimeData("192.168.1.3", 52);
    AddTimeData("192.168.1.4", 48);
    AddTimeData("192.168.1.5", 51);

    REQUIRE(GetTimeOffset() == 51);
}

TEST_CASE("TimeData - CMedianFilter with various sizes", "[timedata]") {
    // Test the median filter directly
    CMedianFilter<int> filter(5, 0);

    REQUIRE(filter.size() == 1);
    REQUIRE(filter.median() == 0);

    filter.input(10);
    REQUIRE(filter.size() == 2);
    REQUIRE(filter.median() == 5);  // (0 + 10) / 2

    filter.input(20);
    REQUIRE(filter.size() == 3);
    REQUIRE(filter.median() == 10);  // Middle of [0, 10, 20]

    filter.input(5);
    REQUIRE(filter.size() == 4);
    REQUIRE(filter.median() == 7);  // (5 + 10) / 2 for [0, 5, 10, 20]

    filter.input(15);
    REQUIRE(filter.size() == 5);
    REQUIRE(filter.median() == 10);  // Middle of [0, 5, 10, 15, 20]
}

TEST_CASE("TimeData - CMedianFilter rolling window", "[timedata]") {
    // Test that filter maintains max size and evicts oldest
    CMedianFilter<int> filter(3, 0);

    filter.input(10);
    filter.input(20);
    REQUIRE(filter.size() == 3);  // [0, 10, 20]
    REQUIRE(filter.median() == 10);

    // Add 4th element, should evict 0 (oldest)
    filter.input(30);
    REQUIRE(filter.size() == 3);  // [10, 20, 30]
    REQUIRE(filter.median() == 20);

    // Add 5th element, should evict 10
    filter.input(5);
    REQUIRE(filter.size() == 3);  // [20, 30, 5]
    REQUIRE(filter.median() == 20);  // Sorted: [5, 20, 30]
}

TEST_CASE("TimeData - Large offset values (within bounds)", "[timedata]") {
    TestOnlyResetTimeData();

    // Test with larger realistic offsets (minutes range)
    // 60, 120, 90, 75, 105 seconds
    // Sorted: [60, 75, 90, 105, 120]
    // Median: 90
    AddTimeData("192.168.1.1", 60);
    AddTimeData("192.168.1.2", 120);
    AddTimeData("192.168.1.3", 90);
    AddTimeData("192.168.1.4", 75);
    AddTimeData("192.168.1.5", 105);

    REQUIRE(GetTimeOffset() == 90);
}

TEST_CASE("TimeData - Zero offsets (perfect sync)", "[timedata]") {
    TestOnlyResetTimeData();

    // All peers report zero offset (perfect clock sync)
    AddTimeData("192.168.1.1", 0);
    AddTimeData("192.168.1.2", 0);
    AddTimeData("192.168.1.3", 0);
    AddTimeData("192.168.1.4", 0);
    AddTimeData("192.168.1.5", 0);

    REQUIRE(GetTimeOffset() == 0);
}
