#!/usr/bin/env python3
"""Generate a pre-mined test chain for batching tests.

This script mines a large chain once and saves it to disk.
The saved chain can then be loaded quickly for testing batching behavior.
"""

import sys
import tempfile
import shutil
import time
from pathlib import Path

# Add test framework to path
sys.path.insert(0, str(Path(__file__).parent / "test_framework"))

from test_node import TestNode


def main():
    """Generate and save test chain."""
    num_blocks = int(sys.argv[1]) if len(sys.argv) > 1 else 2500
    output_dir = Path(sys.argv[2]) if len(sys.argv) > 2 else Path(__file__).parent / "test_chains"

    print(f"Generating test chain with {num_blocks} blocks...")
    print(f"Output directory: {output_dir}")
    print()

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)
    chain_dir = output_dir / f"chain_{num_blocks}_blocks"

    if chain_dir.exists():
        print(f"Chain already exists at {chain_dir}")
        response = input("Overwrite? (y/N): ")
        if response.lower() != 'y':
            print("Aborted.")
            return 0
        shutil.rmtree(chain_dir)

    # Setup temporary directory for node
    test_dir = Path(tempfile.mkdtemp(prefix="coinbasechain_gen_"))
    binary_path = Path(__file__).parent.parent.parent / "build" / "bin" / "coinbasechain"

    node = None

    try:
        print("Starting node...")
        node = TestNode(0, test_dir / "node0", binary_path, extra_args=["--listen", "--port=19500"])
        node.start()

        time.sleep(2)

        # Mine blocks in chunks
        print(f"\nMining {num_blocks} blocks...")
        print("This will take approximately {:.1f} minutes...".format(num_blocks * 0.7 / 60))
        print()

        chunk_size = 10  # Smaller chunks to work with 500ms delay fix
        start_time = time.time()

        for i in range(0, num_blocks, chunk_size):
            blocks_to_mine = min(chunk_size, num_blocks - i)
            node.generate(blocks_to_mine, timeout=300)
            info = node.get_info()

            elapsed = time.time() - start_time
            blocks_done = info['blocks']
            blocks_remaining = num_blocks - blocks_done
            time_per_block = elapsed / blocks_done if blocks_done > 0 else 0.2
            eta = blocks_remaining * time_per_block

            print(f"  Progress: {blocks_done}/{num_blocks} blocks "
                  f"({100*blocks_done/num_blocks:.1f}%) - "
                  f"Elapsed: {elapsed/60:.1f}m, ETA: {eta/60:.1f}m")

        # Verify final height
        info = node.get_info()
        assert info['blocks'] == num_blocks, f"Expected {num_blocks} blocks, got {info['blocks']}"

        total_time = time.time() - start_time
        print(f"\n✓ Mining complete in {total_time/60:.1f} minutes!")
        print(f"  Final height: {info['blocks']}")
        print(f"  Tip: {info['bestblockhash'][:16]}...")

        # Stop node to ensure data is flushed
        print("\nStopping node...")
        node.stop()
        time.sleep(1)

        # Copy the chain data to output directory
        print(f"\nSaving chain to {chain_dir}...")
        shutil.copytree(test_dir / "node0", chain_dir)

        # Create metadata file
        metadata = {
            "blocks": num_blocks,
            "tip": info['bestblockhash'],
            "generated": time.strftime("%Y-%m-%d %H:%M:%S"),
            "time_taken_seconds": int(total_time)
        }

        import json
        with open(chain_dir / "chain_metadata.json", 'w') as f:
            json.dump(metadata, f, indent=2)

        print(f"\n✓ Test chain saved successfully!")
        print(f"  Location: {chain_dir}")
        print(f"  Size: {sum(f.stat().st_size for f in chain_dir.rglob('*') if f.is_file()) / (1024*1024):.1f} MB")
        print(f"\nTo use this chain in tests, copy it to your test node's datadir.")

    except KeyboardInterrupt:
        print("\n\nInterrupted by user")
        return 1
    except Exception as e:
        print(f"\n✗ Failed: {e}")
        import traceback
        traceback.print_exc()
        return 1
    finally:
        # Cleanup
        if node and node.is_running():
            node.stop()

        print(f"\nCleaning up temporary directory: {test_dir}")
        shutil.rmtree(test_dir, ignore_errors=True)

    return 0


if __name__ == "__main__":
    sys.exit(main())
